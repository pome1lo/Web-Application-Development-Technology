const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors());
app.use(express.json());

// Обработчик A с задержкой в 10 секунд
app.post('/handlerA', (req, res) => {
    setTimeout(() => {
        const x = parseInt(req.body.x, 10);
        const y = parseInt(req.body.y, 10);
        if (!isNaN(x) && !isNaN(y)) {
            const sum = x + y;
            res.json({ sum: sum });
        } else {
            res.status(400).json({ error: 'Invalid input' });
        }
    }, 10000);
});


// Обработчик B с задержкой в 1 секунду
app.post('/handlerB', (req, res) => {
    setTimeout(() => {
        const n = parseInt(req.body.n, 10);
        if (!isNaN(n)) {
            const count = Math.floor(Math.random() * (10 - 5 + 1)) + 5;
            const numbers = Array.from({ length: count }, () => Math.floor(Math.random() * (2 * n + 1)) - n);
            res.json({ numbers: numbers });
        } else {
            res.status(400).json({ error: 'Invalid input' });
        }
    }, 1000);
});

// Обработчик C, если он требуется для задания

app.listen(3003, () => {
    console.log('Сервер запущен на порту 3003');
});

//
// 11. При синхронном запросе (третий параметр `open` метода `false`) браузер будет ждать окончания выполнения запроса,
// прежде чем продолжить выполнение JavaScript. Это приведет к "заморозке" страницы на время выполнения запроса, что
// создает плохой пользовательский опыт, так как страница не будет отвечать на взаимодействие пользователя.
//
// 12. При возврате асинхронности (третий параметр `open` метода `true`), запросы будут выполняться в фоновом режиме, и
// пользователь сможет взаимодействовать со страницей во время их выполнения.
//
// 13. При асинхронной работе приложения, вы сможете отправлять все три запроса почти одновременно, не дожидаясь
// окончания предыдущего. Это позволит странице оставаться отзывчивой и улучшит общий пользовательский опыт.
//
// Обязательно установите асинхронность обратно в `true`, чтобы ваши запросы выполнялись асинхронно, и убедитесь, что
// ваш сервер корректно обрабатывает асинхронные запросы